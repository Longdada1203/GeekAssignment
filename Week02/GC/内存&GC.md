### SerialGC
1、随着堆内存增加（1g2g4g8g）的每次GC停顿越来越高  
2、随着内存增加所有次GC的停顿时长总体停顿时长也比较高，吞吐量不高  
3、随着堆内存的增加  

---

### ParallelGC
1、随着堆内存增加的每次GC停顿越来越高，但是要大大低于SerialGC  
2、随着内存增加总体停顿时长要低于G1和串行GC，吞吐量高  

--- 


### G1GC
1、随着堆内存的增加每次GC停顿也会增加，但随着堆内存的增大（4g）以上之后变换非常不明显  
2、随着内存增加总体停顿时长要大于ParallelGC，吞吐量低于ParallelGC  

--- 


### ZGC
1、随着堆内存很小（1g）的时候会有GC停顿，随着堆内存的增加，GC几乎没有停顿了  

--- 


### 总结
#### GC的选择
1、当前一般都是多核多线程CPU，SerialGC已经不适用，要么选用ParallelGC，要么选用G1  
2、对系统的低延迟没有要求的建议使用ParallelGC，比如一般的政务网站，购物网站等  
3、对系统的低延迟要求很高的建议使用G1GC，比如金融交易系统  
4、随着堆内存的增加不论哪种GC的性能都在增强，总体GC时间都在减少，建议在系统总内存量允许的情况下，堆内存尽量的大，但是不要超过系统内存的1/4  
5、内存非常大（16g以上）还是推荐使用G1GC，G1GC随着内存的增加单词GC停顿变化非常小  
6、当前一般的系统堆内存配置都不大，一般2G-4G，这种情况下如果不是对低延迟有极致要求，推荐使用ParallelGC  
7、我当前使用JDK16 CMSGC已经被废弃，建议使用G1GC替代CMSGC  
8、Xmx和Xms建议设置一样大，不设置Xms或者设置很小的Xms时FullGC的次数明显多于Xms与Xmx一样大的情况

#### 常见的内存异常
1、OutOfMemoryError：PermGen space，永久代或者元数据区溢出，从JDK8开始，永久代就被取消了，可能是系统在启动的时候加载了过多的类，Java虚拟机装装载类空间不够，建议修改Java虚拟机启动的元数据区参数，将其设置更大  
2、OutOfMemoryError：Java heap space，Java程序创建的对象过多，在某次GC之前堆内存被占满了，建议检查代码中是否有死循环导致该回收的对象实例没被回收，另外就是检查Java虚拟机中Xms和Xmx的参数是否设置太小  
3、OutOfMemoryError：unable to create new native thread，可能是创建线程数超过了操作系统的限制需要修改sysctl kernel.pid_max参数  
4、StackOverflowError方法调用太深，我们的栈内存深度一般设置为默认值1m是足够用的，发生这个错误一般都是代码问题，可能是方法循环调用，需要优化代码
